{
  "title": "Container Deep Dive",
  "description": "Containers",
  "date": "2025-03-17T00:00:00.000Z",
  "body": {
    "raw": "\n## What is a container?\n\nA container is a standardized unit of software that packages code and all its dependencies so that software can run quickly and consistently in any environment.\n\ncharacteristics:\n\n- immutability\n- isolation of processes and computing resources\n- lightweight, runs as a process on the operating system\n\ncontainer vs virtual machine:\n\n- Virtual Machines (VMs): Each VM runs a complete operating system, including the kernel, and uses a hypervisor to manage multiple VMs on the same hardware. This results in higher resource consumption, longer startup times, and less efficiency in terms of memory and CPU usage.\n- Containers: Share the host operating system's kernel, isolating only the application and its dependencies. This makes them significantly lighter, allowing for more efficient use of resources and almost instantaneous startup. Containers are ideal for scenarios that require rapid scalability and high density of applications on a single host.\n\n<Image\n  src=\"/vmxdocker.png\"\n  width=\"718\"\n  height=\"404\"\n  alt=\"Container vs Docker\"\n/>\n\n## Namespaces and isolation of resources\n\nNamespaces are used so that a container can be executed safely. We need mechanisms to ensure the isolation of resources and processes.\n\nMain technology behind containers to achieve isolation:\n\n- PID (Process ID): Process isolation.\n- NET (Network): Isolation of network interfaces and stack.\n- MNT (Mount): File system isolation.\n- UTS (Unix Timesharing System): Hostname isolation.\n- IPC (Inter-Process Communication): Isolation of communication between processes.\n- USER: User identity isolation.\n\n## Cgroups and control of resources\n\ncgroups (Control Groups)\nA Linux Kernel feature that allows limiting, monitoring, and isolating resource usage of processes\n\n- CPU\n- Memory\n- Disk\n- Network\n\n<Image\n  src=\"/cgroup.png\"\n  width=\"718\"\n  height=\"404\"\n  alt=\"Cgroups and Namespaces\"\n/>\n\n## LXC - Linux Containers\n\nSystem responsible for executing and managing containers, creating an isolated environment so that applications can be executed consistently and efficiently.\n\n- Isolation\n- Resource management\n- Network management and communication between containers\n- Storage: volume management and file systems (Overlay)\n- Monitoring, metrics, logs, and container state\n- Does not have a friendly user interface by default\n- Requires greater knowledge of Linux administration\n\nmost well known:\n\n- LXC - Linux Containers\n- Docker\n- rkt (Rocket)\n- CRI-O\n- Podman\n\nLXC (Linux Containers) - 2008\n\n- First container system that offered a lightweight virtualization environment using cgroups and namespaces of Linux.\n- Is considered low level compared to solutions like Docker, which offer more abstraction and ease of use\n- Uses Linux tools\n- Does not have a friendly user interface by default\n- Requires more knowledge of Linux administration\n\n## Open Container Initiative (OCI)\n\nOpen Container Initiative (OCI):\nThe Open Container Initiative (OCI) is an open and lightweight governance structure, created under the Linux Foundation, with the purpose of establishing open industry standards for container formats and runtimes. The OCI was launched on June 22, 2015, by Docker, CoreOS, and other container industry leaders.\n\nCurrently, the OCI contains three main specifications:\n\n- Runtime Specification (runtime-spec): Defines how to execute a \"filesystem bundle\" that is unpacked on disk. It establishes how the environment should be configured for the container to be started, including requirements such as cgroups, namespaces, device configurations, and permissions.\n- Image Specification (image-spec): Defines how to create an OCI image, which includes the image manifest, filesystem serialization (layers), and image configurations. The image manifest contains metadata about the content and dependencies of the image, while the configuration includes information such as execution commands, environment variables, and other configurations needed to start the container.\n- Distribution Specification (distribution-spec): Introduced in 2020, standardizes the API for container image distribution. This specification is designed to be generic enough to be used as a distribution mechanism for any type of content, allowing container images to be easily stored and retrieved from registries, such as Docker Hub.\n\n## Containerd and runc\n\n- containerd is a lower-level container runtime that manages the container lifecycle, including execution, pausing, stopping, and removing containers. It is a separate project, originally part of Docker, but now an independent component maintained by the Cloud Native Computing Foundation (CNCF).\n  - Relationship between Docker and containerd: Docker uses containerd as one of its fundamental components to efficiently manage containers. Docker's architecture is built on containerd, which in turn uses runc (OCI-compatible) to create and run containers at the system level. Docker CLI and Docker Daemon communicate with containerd to perform high-level operations, such as creating new containers or executing commands in them.\n  - Benefits of containerd: Separating containerd as an independent project brought greater modularity and flexibility to the container ecosystem. Other tools and orchestrators, such as Kubernetes, also use containerd as the standard runtime due to its efficiency and adherence to OCI standards.\n\nThe main components of containerd include:\n\n- Main Daemon: The central service that coordinates all container-related operations, functioning as a gRPC server to manage the container lifecycle (GitHub).\n\n- Client: An interface that allows users to interact with the containerd daemon, sending commands and receiving responses for operations such as creating, running, and managing containers (GitHub).\n\n- Image Storage: Manages the download, storage, and distribution of container images, ensuring that the necessary images are available for container execution (containerd).\n\n- Container Execution: Responsible for starting and supervising the execution of containers, ensuring they operate as expected (containerd).\n\n- Network Primitives: Provides functionality for creating, modifying, and deleting network interfaces, allowing containers to connect to networks as needed (containerd).\n\n- CRI Plugin (Container Runtime Interface): Implements the container runtime interface for Kubernetes, allowing containerd to be used as a runtime in Kubernetes environments (GitHub).\n\n### How containerd and runc work together\n\n- containerd and runc work together to create and manage containers in Docker and other containerization systems that follow the OCI standard.\n- When you run a command like docker run, the Docker CLI communicates with the Docker Daemon to request the creation of a new container.\n- The Docker Daemon then communicates with containerd to manage the container lifecycle.\n- containerd uses runc to effectively create the container, applying all isolation configurations, such as namespaces and cgroups.\n- runc creates the isolated process and configures namespaces and cgroups as defined by OCI specifications. It executes the initial process inside the container (for example, /bin/sh or any specified command).\n- Once the container is running, containerd continues to monitor its state and allows commands such as pause, resume, and stop to be executed through the gRPC API.\n\n### Difference between containerd and Docker Daemon\n\nDocker Daemon: The Docker Daemon (dockerd) is the main process that coordinates all Docker-related operations. It receives commands from the Docker CLI, interacts with containerd, and manages images, containers, networks, and volumes. The Docker Daemon is responsible for providing the high-level interface for developers and operators who use Docker to manage containers easily.\n\ncontainerd: containerd is a lower-level container runtime that handles the container lifecycle, including execution, pausing, restarting, and removing containers. containerd was created to be a modular and independent tool that can be used by other container orchestrators such as Kubernetes. It is responsible for communicating directly with runc for container creation, while the Docker Daemon is more focused on providing a high-level interface and management functionality.\n\nRelationship between containerd and Docker Daemon: The Docker Daemon is built on top of containerd. When you run a Docker command, the Docker Daemon delegates container-related operations to containerd, which in turn uses runc to effectively create and run the container. Thus, the Docker Daemon serves as an orchestration and abstraction layer, while containerd performs lower-level operations.\n\n### About runC\n\nrunc is the low-level container runtime that follows the Open Container Initiative (OCI) specifications, ensuring that any container created with runc complies with the standards defined for portability and interoperability between container tools.\n\nFunction of runc: runc is responsible for creating and executing containers at the lowest level of the system. It uses Linux kernel features, such as namespaces and cgroups, to create an isolated and controlled environment where a container runs. runc is responsible for applying isolation configurations, setting resource limits, and starting the main process inside the container.\n\nHow runc Works: When the command to create a container is passed by containerd, runc reads the generated configuration file, which defines details such as namespaces, cgroups, devices, environment variables, among others. From this configuration, runc creates an isolated process that will be the container. runc does not manage the container lifecycle after its creation, as this is containerd's function.\n\nOCI and runc: By being compatible with OCI specifications, runc ensures that the container format and execution practices are standardized, which means that containers created with runc are portable and can be run in other OCI-compatible environments.\n\nHistory of runc: Originally, runc was an integral part of Docker, but with the creation of OCI, it was extracted and transformed into an independent project to serve as a universal container runtime. This helped promote a more open and interoperable ecosystem, where multiple tools can share the same runtime.\n\nOperation:\n\n- If you have containerd and runc installed, it's possible to create a container directly without using Docker. First, you must prepare a configuration for the container using a JSON file following OCI specifications.\n\n- Then, runc can be used to initialize the container with this configuration file. This process demonstrates how runc acts as the direct executor of the container, while containerd or Docker provide the abstraction layer to facilitate management.\n\n## Filesystem - tmpfs, proc, sysfs, mqueue, debugfs, cgroups\n",
    "code": "var Component=(()=>{var un=Object.create;var P=Object.defineProperty;var dn=Object.getOwnPropertyDescriptor;var cn=Object.getOwnPropertyNames;var mn=Object.getPrototypeOf,fn=Object.prototype.hasOwnProperty;var H=(u,n)=>()=>(n||u((n={exports:{}}).exports,n),n.exports),bn=(u,n)=>{for(var f in n)P(u,f,{get:n[f],enumerable:!0})},ye=(u,n,f,x)=>{if(n&&typeof n==\"object\"||typeof n==\"function\")for(let N of cn(n))!fn.call(u,N)&&N!==f&&P(u,N,{get:()=>n[N],enumerable:!(x=dn(n,N))||x.enumerable});return u};var pn=(u,n,f)=>(f=u!=null?un(mn(u)):{},ye(n||!u||!u.__esModule?P(f,\"default\",{value:u,enumerable:!0}):f,u)),hn=u=>ye(P({},\"__esModule\",{value:!0}),u);var De=H((Dn,ve)=>{ve.exports=React});var je=H(B=>{\"use strict\";(function(){\"use strict\";var u=De(),n=Symbol.for(\"react.element\"),f=Symbol.for(\"react.portal\"),x=Symbol.for(\"react.fragment\"),N=Symbol.for(\"react.strict_mode\"),G=Symbol.for(\"react.profiler\"),K=Symbol.for(\"react.provider\"),X=Symbol.for(\"react.context\"),C=Symbol.for(\"react.forward_ref\"),S=Symbol.for(\"react.suspense\"),F=Symbol.for(\"react.suspense_list\"),E=Symbol.for(\"react.memo\"),A=Symbol.for(\"react.lazy\"),Ee=Symbol.for(\"react.offscreen\"),J=Symbol.iterator,ke=\"@@iterator\";function Re(e){if(e===null||typeof e!=\"object\")return null;var r=J&&e[J]||e[ke];return typeof r==\"function\"?r:null}var v=u.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;function b(e){{for(var r=arguments.length,i=new Array(r>1?r-1:0),o=1;o<r;o++)i[o-1]=arguments[o];Te(\"error\",e,i)}}function Te(e,r,i){{var o=v.ReactDebugCurrentFrame,l=o.getStackAddendum();l!==\"\"&&(r+=\"%s\",i=i.concat([l]));var d=i.map(function(a){return String(a)});d.unshift(\"Warning: \"+r),Function.prototype.apply.call(console[e],console,d)}}var Oe=!1,Ie=!1,Pe=!1,Se=!1,Fe=!1,Z;Z=Symbol.for(\"react.module.reference\");function Ae(e){return!!(typeof e==\"string\"||typeof e==\"function\"||e===x||e===G||Fe||e===N||e===S||e===F||Se||e===Ee||Oe||Ie||Pe||typeof e==\"object\"&&e!==null&&(e.$$typeof===A||e.$$typeof===E||e.$$typeof===K||e.$$typeof===X||e.$$typeof===C||e.$$typeof===Z||e.getModuleId!==void 0))}function Le(e,r,i){var o=e.displayName;if(o)return o;var l=r.displayName||r.name||\"\";return l!==\"\"?i+\"(\"+l+\")\":i}function Q(e){return e.displayName||\"Context\"}function _(e){if(e==null)return null;if(typeof e.tag==\"number\"&&b(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"),typeof e==\"function\")return e.displayName||e.name||null;if(typeof e==\"string\")return e;switch(e){case x:return\"Fragment\";case f:return\"Portal\";case G:return\"Profiler\";case N:return\"StrictMode\";case S:return\"Suspense\";case F:return\"SuspenseList\"}if(typeof e==\"object\")switch(e.$$typeof){case X:var r=e;return Q(r)+\".Consumer\";case K:var i=e;return Q(i._context)+\".Provider\";case C:return Le(e,e.render,\"ForwardRef\");case E:var o=e.displayName||null;return o!==null?o:_(e.type)||\"Memo\";case A:{var l=e,d=l._payload,a=l._init;try{return _(a(d))}catch{return null}}}return null}var y=Object.assign,w=0,ee,ne,te,re,ie,oe,se;function ae(){}ae.__reactDisabledLog=!0;function Me(){{if(w===0){ee=console.log,ne=console.info,te=console.warn,re=console.error,ie=console.group,oe=console.groupCollapsed,se=console.groupEnd;var e={configurable:!0,enumerable:!0,value:ae,writable:!0};Object.defineProperties(console,{info:e,log:e,warn:e,error:e,group:e,groupCollapsed:e,groupEnd:e})}w++}}function We(){{if(w--,w===0){var e={configurable:!0,enumerable:!0,writable:!0};Object.defineProperties(console,{log:y({},e,{value:ee}),info:y({},e,{value:ne}),warn:y({},e,{value:te}),error:y({},e,{value:re}),group:y({},e,{value:ie}),groupCollapsed:y({},e,{value:oe}),groupEnd:y({},e,{value:se})})}w<0&&b(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\")}}var L=v.ReactCurrentDispatcher,M;function k(e,r,i){{if(M===void 0)try{throw Error()}catch(l){var o=l.stack.trim().match(/\\n( *(at )?)/);M=o&&o[1]||\"\"}return`\n`+M+e}}var W=!1,R;{var Ve=typeof WeakMap==\"function\"?WeakMap:Map;R=new Ve}function le(e,r){if(!e||W)return\"\";{var i=R.get(e);if(i!==void 0)return i}var o;W=!0;var l=Error.prepareStackTrace;Error.prepareStackTrace=void 0;var d;d=L.current,L.current=null,Me();try{if(r){var a=function(){throw Error()};if(Object.defineProperty(a.prototype,\"props\",{set:function(){throw Error()}}),typeof Reflect==\"object\"&&Reflect.construct){try{Reflect.construct(a,[])}catch(g){o=g}Reflect.construct(e,[],a)}else{try{a.call()}catch(g){o=g}e.call(a.prototype)}}else{try{throw Error()}catch(g){o=g}e()}}catch(g){if(g&&o&&typeof g.stack==\"string\"){for(var s=g.stack.split(`\n`),p=o.stack.split(`\n`),c=s.length-1,m=p.length-1;c>=1&&m>=0&&s[c]!==p[m];)m--;for(;c>=1&&m>=0;c--,m--)if(s[c]!==p[m]){if(c!==1||m!==1)do if(c--,m--,m<0||s[c]!==p[m]){var h=`\n`+s[c].replace(\" at new \",\" at \");return e.displayName&&h.includes(\"<anonymous>\")&&(h=h.replace(\"<anonymous>\",e.displayName)),typeof e==\"function\"&&R.set(e,h),h}while(c>=1&&m>=0);break}}}finally{W=!1,L.current=d,We(),Error.prepareStackTrace=l}var j=e?e.displayName||e.name:\"\",xe=j?k(j):\"\";return typeof e==\"function\"&&R.set(e,xe),xe}function Ye(e,r,i){return le(e,!1)}function $e(e){var r=e.prototype;return!!(r&&r.isReactComponent)}function T(e,r,i){if(e==null)return\"\";if(typeof e==\"function\")return le(e,$e(e));if(typeof e==\"string\")return k(e);switch(e){case S:return k(\"Suspense\");case F:return k(\"SuspenseList\")}if(typeof e==\"object\")switch(e.$$typeof){case C:return Ye(e.render);case E:return T(e.type,r,i);case A:{var o=e,l=o._payload,d=o._init;try{return T(d(l),r,i)}catch{}}}return\"\"}var O=Object.prototype.hasOwnProperty,ue={},de=v.ReactDebugCurrentFrame;function I(e){if(e){var r=e._owner,i=T(e.type,e._source,r?r.type:null);de.setExtraStackFrame(i)}else de.setExtraStackFrame(null)}function qe(e,r,i,o,l){{var d=Function.call.bind(O);for(var a in e)if(d(e,a)){var s=void 0;try{if(typeof e[a]!=\"function\"){var p=Error((o||\"React class\")+\": \"+i+\" type `\"+a+\"` is invalid; it must be a function, usually from the `prop-types` package, but received `\"+typeof e[a]+\"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");throw p.name=\"Invariant Violation\",p}s=e[a](r,a,o,i,null,\"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\")}catch(c){s=c}s&&!(s instanceof Error)&&(I(l),b(\"%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\",o||\"React class\",i,a,typeof s),I(null)),s instanceof Error&&!(s.message in ue)&&(ue[s.message]=!0,I(l),b(\"Failed %s type: %s\",i,s.message),I(null))}}}var ze=Array.isArray;function V(e){return ze(e)}function He(e){{var r=typeof Symbol==\"function\"&&Symbol.toStringTag,i=r&&e[Symbol.toStringTag]||e.constructor.name||\"Object\";return i}}function Be(e){try{return ce(e),!1}catch{return!0}}function ce(e){return\"\"+e}function me(e){if(Be(e))return b(\"The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.\",He(e)),ce(e)}var U=v.ReactCurrentOwner,Ge={key:!0,ref:!0,__self:!0,__source:!0},fe,be,Y;Y={};function Ke(e){if(O.call(e,\"ref\")){var r=Object.getOwnPropertyDescriptor(e,\"ref\").get;if(r&&r.isReactWarning)return!1}return e.ref!==void 0}function Xe(e){if(O.call(e,\"key\")){var r=Object.getOwnPropertyDescriptor(e,\"key\").get;if(r&&r.isReactWarning)return!1}return e.key!==void 0}function Je(e,r){if(typeof e.ref==\"string\"&&U.current&&r&&U.current.stateNode!==r){var i=_(U.current.type);Y[i]||(b('Component \"%s\" contains the string ref \"%s\". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref',_(U.current.type),e.ref),Y[i]=!0)}}function Ze(e,r){{var i=function(){fe||(fe=!0,b(\"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\",r))};i.isReactWarning=!0,Object.defineProperty(e,\"key\",{get:i,configurable:!0})}}function Qe(e,r){{var i=function(){be||(be=!0,b(\"%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\",r))};i.isReactWarning=!0,Object.defineProperty(e,\"ref\",{get:i,configurable:!0})}}var en=function(e,r,i,o,l,d,a){var s={$$typeof:n,type:e,key:r,ref:i,props:a,_owner:d};return s._store={},Object.defineProperty(s._store,\"validated\",{configurable:!1,enumerable:!1,writable:!0,value:!1}),Object.defineProperty(s,\"_self\",{configurable:!1,enumerable:!1,writable:!1,value:o}),Object.defineProperty(s,\"_source\",{configurable:!1,enumerable:!1,writable:!1,value:l}),Object.freeze&&(Object.freeze(s.props),Object.freeze(s)),s};function nn(e,r,i,o,l){{var d,a={},s=null,p=null;i!==void 0&&(me(i),s=\"\"+i),Xe(r)&&(me(r.key),s=\"\"+r.key),Ke(r)&&(p=r.ref,Je(r,l));for(d in r)O.call(r,d)&&!Ge.hasOwnProperty(d)&&(a[d]=r[d]);if(e&&e.defaultProps){var c=e.defaultProps;for(d in c)a[d]===void 0&&(a[d]=c[d])}if(s||p){var m=typeof e==\"function\"?e.displayName||e.name||\"Unknown\":e;s&&Ze(a,m),p&&Qe(a,m)}return en(e,s,p,l,o,U.current,a)}}var $=v.ReactCurrentOwner,pe=v.ReactDebugCurrentFrame;function D(e){if(e){var r=e._owner,i=T(e.type,e._source,r?r.type:null);pe.setExtraStackFrame(i)}else pe.setExtraStackFrame(null)}var q;q=!1;function z(e){return typeof e==\"object\"&&e!==null&&e.$$typeof===n}function he(){{if($.current){var e=_($.current.type);if(e)return`\n\nCheck the render method of \\``+e+\"`.\"}return\"\"}}function tn(e){{if(e!==void 0){var r=e.fileName.replace(/^.*[\\\\\\/]/,\"\"),i=e.lineNumber;return`\n\nCheck your code at `+r+\":\"+i+\".\"}return\"\"}}var _e={};function rn(e){{var r=he();if(!r){var i=typeof e==\"string\"?e:e.displayName||e.name;i&&(r=`\n\nCheck the top-level render call using <`+i+\">.\")}return r}}function ge(e,r){{if(!e._store||e._store.validated||e.key!=null)return;e._store.validated=!0;var i=rn(r);if(_e[i])return;_e[i]=!0;var o=\"\";e&&e._owner&&e._owner!==$.current&&(o=\" It was passed a child from \"+_(e._owner.type)+\".\"),D(e),b('Each child in a list should have a unique \"key\" prop.%s%s See https://reactjs.org/link/warning-keys for more information.',i,o),D(null)}}function Ne(e,r){{if(typeof e!=\"object\")return;if(V(e))for(var i=0;i<e.length;i++){var o=e[i];z(o)&&ge(o,r)}else if(z(e))e._store&&(e._store.validated=!0);else if(e){var l=Re(e);if(typeof l==\"function\"&&l!==e.entries)for(var d=l.call(e),a;!(a=d.next()).done;)z(a.value)&&ge(a.value,r)}}}function on(e){{var r=e.type;if(r==null||typeof r==\"string\")return;var i;if(typeof r==\"function\")i=r.propTypes;else if(typeof r==\"object\"&&(r.$$typeof===C||r.$$typeof===E))i=r.propTypes;else return;if(i){var o=_(r);qe(i,e.props,\"prop\",o,e)}else if(r.PropTypes!==void 0&&!q){q=!0;var l=_(r);b(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\",l||\"Unknown\")}typeof r.getDefaultProps==\"function\"&&!r.getDefaultProps.isReactClassApproved&&b(\"getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.\")}}function sn(e){{for(var r=Object.keys(e.props),i=0;i<r.length;i++){var o=r[i];if(o!==\"children\"&&o!==\"key\"){D(e),b(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\",o),D(null);break}}e.ref!==null&&(D(e),b(\"Invalid attribute `ref` supplied to `React.Fragment`.\"),D(null))}}function an(e,r,i,o,l,d){{var a=Ae(e);if(!a){var s=\"\";(e===void 0||typeof e==\"object\"&&e!==null&&Object.keys(e).length===0)&&(s+=\" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\");var p=tn(l);p?s+=p:s+=he();var c;e===null?c=\"null\":V(e)?c=\"array\":e!==void 0&&e.$$typeof===n?(c=\"<\"+(_(e.type)||\"Unknown\")+\" />\",s=\" Did you accidentally export a JSX literal instead of a component?\"):c=typeof e,b(\"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\",c,s)}var m=nn(e,r,i,l,d);if(m==null)return m;if(a){var h=r.children;if(h!==void 0)if(o)if(V(h)){for(var j=0;j<h.length;j++)Ne(h[j],e);Object.freeze&&Object.freeze(h)}else b(\"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\");else Ne(h,e)}return e===x?sn(m):on(m),m}}var ln=an;B.Fragment=x,B.jsxDEV=ln})()});var Ue=H((wn,we)=>{\"use strict\";we.exports=je()});var yn={};bn(yn,{default:()=>Nn,frontmatter:()=>_n});var t=pn(Ue()),_n={title:\"Container Deep Dive\",description:\"Containers\",date:\"2025-03-17\"};function Ce(u){let n=Object.assign({h2:\"h2\",p:\"p\",ul:\"ul\",li:\"li\",h3:\"h3\"},u.components),{Image:f}=n;return f||xn(\"Image\",!0,\"22:1-27:3\"),(0,t.jsxDEV)(t.Fragment,{children:[(0,t.jsxDEV)(n.h2,{children:\"What is a container?\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:7,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"A container is a standardized unit of software that packages code and all its dependencies so that software can run quickly and consistently in any environment.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:9,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"characteristics:\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:11,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.ul,{children:[`\n`,(0,t.jsxDEV)(n.li,{children:\"immutability\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:13,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"isolation of processes and computing resources\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:14,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"lightweight, runs as a process on the operating system\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:15,columnNumber:1},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:13,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"container vs virtual machine:\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:17,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.ul,{children:[`\n`,(0,t.jsxDEV)(n.li,{children:\"Virtual Machines (VMs): Each VM runs a complete operating system, including the kernel, and uses a hypervisor to manage multiple VMs on the same hardware. This results in higher resource consumption, longer startup times, and less efficiency in terms of memory and CPU usage.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:19,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"Containers: Share the host operating system's kernel, isolating only the application and its dependencies. This makes them significantly lighter, allowing for more efficient use of resources and almost instantaneous startup. Containers are ideal for scenarios that require rapid scalability and high density of applications on a single host.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:20,columnNumber:1},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:19,columnNumber:1},this),`\n`,(0,t.jsxDEV)(f,{src:\"/vmxdocker.png\",width:\"718\",height:\"404\",alt:\"Container vs Docker\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:22,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.h2,{children:\"Namespaces and isolation of resources\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:29,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"Namespaces are used so that a container can be executed safely. We need mechanisms to ensure the isolation of resources and processes.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:31,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"Main technology behind containers to achieve isolation:\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:33,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.ul,{children:[`\n`,(0,t.jsxDEV)(n.li,{children:\"PID (Process ID): Process isolation.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:35,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"NET (Network): Isolation of network interfaces and stack.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:36,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"MNT (Mount): File system isolation.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:37,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"UTS (Unix Timesharing System): Hostname isolation.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:38,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"IPC (Inter-Process Communication): Isolation of communication between processes.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:39,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"USER: User identity isolation.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:40,columnNumber:1},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:35,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.h2,{children:\"Cgroups and control of resources\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:42,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:`cgroups (Control Groups)\nA Linux Kernel feature that allows limiting, monitoring, and isolating resource usage of processes`},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:44,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.ul,{children:[`\n`,(0,t.jsxDEV)(n.li,{children:\"CPU\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:47,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"Memory\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:48,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"Disk\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:49,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"Network\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:50,columnNumber:1},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:47,columnNumber:1},this),`\n`,(0,t.jsxDEV)(f,{src:\"/cgroup.png\",width:\"718\",height:\"404\",alt:\"Cgroups and Namespaces\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:52,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.h2,{children:\"LXC - Linux Containers\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:59,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"System responsible for executing and managing containers, creating an isolated environment so that applications can be executed consistently and efficiently.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:61,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.ul,{children:[`\n`,(0,t.jsxDEV)(n.li,{children:\"Isolation\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:63,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"Resource management\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:64,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"Network management and communication between containers\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:65,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"Storage: volume management and file systems (Overlay)\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:66,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"Monitoring, metrics, logs, and container state\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:67,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"Does not have a friendly user interface by default\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:68,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"Requires greater knowledge of Linux administration\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:69,columnNumber:1},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:63,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"most well known:\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:71,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.ul,{children:[`\n`,(0,t.jsxDEV)(n.li,{children:\"LXC - Linux Containers\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:73,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"Docker\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:74,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"rkt (Rocket)\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:75,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"CRI-O\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:76,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"Podman\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:77,columnNumber:1},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:73,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"LXC (Linux Containers) - 2008\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:79,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.ul,{children:[`\n`,(0,t.jsxDEV)(n.li,{children:\"First container system that offered a lightweight virtualization environment using cgroups and namespaces of Linux.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:81,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"Is considered low level compared to solutions like Docker, which offer more abstraction and ease of use\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:82,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"Uses Linux tools\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:83,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"Does not have a friendly user interface by default\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:84,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"Requires more knowledge of Linux administration\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:85,columnNumber:1},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:81,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.h2,{children:\"Open Container Initiative (OCI)\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:87,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:`Open Container Initiative (OCI):\nThe Open Container Initiative (OCI) is an open and lightweight governance structure, created under the Linux Foundation, with the purpose of establishing open industry standards for container formats and runtimes. The OCI was launched on June 22, 2015, by Docker, CoreOS, and other container industry leaders.`},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:89,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"Currently, the OCI contains three main specifications:\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:92,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.ul,{children:[`\n`,(0,t.jsxDEV)(n.li,{children:'Runtime Specification (runtime-spec): Defines how to execute a \"filesystem bundle\" that is unpacked on disk. It establishes how the environment should be configured for the container to be started, including requirements such as cgroups, namespaces, device configurations, and permissions.'},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:94,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"Image Specification (image-spec): Defines how to create an OCI image, which includes the image manifest, filesystem serialization (layers), and image configurations. The image manifest contains metadata about the content and dependencies of the image, while the configuration includes information such as execution commands, environment variables, and other configurations needed to start the container.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:95,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"Distribution Specification (distribution-spec): Introduced in 2020, standardizes the API for container image distribution. This specification is designed to be generic enough to be used as a distribution mechanism for any type of content, allowing container images to be easily stored and retrieved from registries, such as Docker Hub.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:96,columnNumber:1},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:94,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.h2,{children:\"Containerd and runc\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:98,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.ul,{children:[`\n`,(0,t.jsxDEV)(n.li,{children:[\"containerd is a lower-level container runtime that manages the container lifecycle, including execution, pausing, stopping, and removing containers. It is a separate project, originally part of Docker, but now an independent component maintained by the Cloud Native Computing Foundation (CNCF).\",`\n`,(0,t.jsxDEV)(n.ul,{children:[`\n`,(0,t.jsxDEV)(n.li,{children:\"Relationship between Docker and containerd: Docker uses containerd as one of its fundamental components to efficiently manage containers. Docker's architecture is built on containerd, which in turn uses runc (OCI-compatible) to create and run containers at the system level. Docker CLI and Docker Daemon communicate with containerd to perform high-level operations, such as creating new containers or executing commands in them.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:101,columnNumber:3},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"Benefits of containerd: Separating containerd as an independent project brought greater modularity and flexibility to the container ecosystem. Other tools and orchestrators, such as Kubernetes, also use containerd as the standard runtime due to its efficiency and adherence to OCI standards.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:102,columnNumber:3},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:101,columnNumber:3},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:100,columnNumber:1},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:100,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"The main components of containerd include:\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:104,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.ul,{children:[`\n`,(0,t.jsxDEV)(n.li,{children:[`\n`,(0,t.jsxDEV)(n.p,{children:\"Main Daemon: The central service that coordinates all container-related operations, functioning as a gRPC server to manage the container lifecycle (GitHub).\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:106,columnNumber:3},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:106,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:[`\n`,(0,t.jsxDEV)(n.p,{children:\"Client: An interface that allows users to interact with the containerd daemon, sending commands and receiving responses for operations such as creating, running, and managing containers (GitHub).\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:108,columnNumber:3},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:108,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:[`\n`,(0,t.jsxDEV)(n.p,{children:\"Image Storage: Manages the download, storage, and distribution of container images, ensuring that the necessary images are available for container execution (containerd).\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:110,columnNumber:3},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:110,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:[`\n`,(0,t.jsxDEV)(n.p,{children:\"Container Execution: Responsible for starting and supervising the execution of containers, ensuring they operate as expected (containerd).\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:112,columnNumber:3},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:112,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:[`\n`,(0,t.jsxDEV)(n.p,{children:\"Network Primitives: Provides functionality for creating, modifying, and deleting network interfaces, allowing containers to connect to networks as needed (containerd).\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:114,columnNumber:3},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:114,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:[`\n`,(0,t.jsxDEV)(n.p,{children:\"CRI Plugin (Container Runtime Interface): Implements the container runtime interface for Kubernetes, allowing containerd to be used as a runtime in Kubernetes environments (GitHub).\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:116,columnNumber:3},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:116,columnNumber:1},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:106,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.h3,{children:\"How containerd and runc work together\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:118,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.ul,{children:[`\n`,(0,t.jsxDEV)(n.li,{children:\"containerd and runc work together to create and manage containers in Docker and other containerization systems that follow the OCI standard.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:120,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"When you run a command like docker run, the Docker CLI communicates with the Docker Daemon to request the creation of a new container.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:121,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"The Docker Daemon then communicates with containerd to manage the container lifecycle.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:122,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"containerd uses runc to effectively create the container, applying all isolation configurations, such as namespaces and cgroups.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:123,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"runc creates the isolated process and configures namespaces and cgroups as defined by OCI specifications. It executes the initial process inside the container (for example, /bin/sh or any specified command).\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:124,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"Once the container is running, containerd continues to monitor its state and allows commands such as pause, resume, and stop to be executed through the gRPC API.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:125,columnNumber:1},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:120,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.h3,{children:\"Difference between containerd and Docker Daemon\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:127,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"Docker Daemon: The Docker Daemon (dockerd) is the main process that coordinates all Docker-related operations. It receives commands from the Docker CLI, interacts with containerd, and manages images, containers, networks, and volumes. The Docker Daemon is responsible for providing the high-level interface for developers and operators who use Docker to manage containers easily.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:129,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"containerd: containerd is a lower-level container runtime that handles the container lifecycle, including execution, pausing, restarting, and removing containers. containerd was created to be a modular and independent tool that can be used by other container orchestrators such as Kubernetes. It is responsible for communicating directly with runc for container creation, while the Docker Daemon is more focused on providing a high-level interface and management functionality.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:131,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"Relationship between containerd and Docker Daemon: The Docker Daemon is built on top of containerd. When you run a Docker command, the Docker Daemon delegates container-related operations to containerd, which in turn uses runc to effectively create and run the container. Thus, the Docker Daemon serves as an orchestration and abstraction layer, while containerd performs lower-level operations.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:133,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.h3,{children:\"About runC\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:135,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"runc is the low-level container runtime that follows the Open Container Initiative (OCI) specifications, ensuring that any container created with runc complies with the standards defined for portability and interoperability between container tools.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:137,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"Function of runc: runc is responsible for creating and executing containers at the lowest level of the system. It uses Linux kernel features, such as namespaces and cgroups, to create an isolated and controlled environment where a container runs. runc is responsible for applying isolation configurations, setting resource limits, and starting the main process inside the container.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:139,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"How runc Works: When the command to create a container is passed by containerd, runc reads the generated configuration file, which defines details such as namespaces, cgroups, devices, environment variables, among others. From this configuration, runc creates an isolated process that will be the container. runc does not manage the container lifecycle after its creation, as this is containerd's function.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:141,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"OCI and runc: By being compatible with OCI specifications, runc ensures that the container format and execution practices are standardized, which means that containers created with runc are portable and can be run in other OCI-compatible environments.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:143,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"History of runc: Originally, runc was an integral part of Docker, but with the creation of OCI, it was extracted and transformed into an independent project to serve as a universal container runtime. This helped promote a more open and interoperable ecosystem, where multiple tools can share the same runtime.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:145,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"Operation:\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:147,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.ul,{children:[`\n`,(0,t.jsxDEV)(n.li,{children:[`\n`,(0,t.jsxDEV)(n.p,{children:\"If you have containerd and runc installed, it's possible to create a container directly without using Docker. First, you must prepare a configuration for the container using a JSON file following OCI specifications.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:149,columnNumber:3},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:149,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:[`\n`,(0,t.jsxDEV)(n.p,{children:\"Then, runc can be used to initialize the container with this configuration file. This process demonstrates how runc acts as the direct executor of the container, while containerd or Docker provide the abstraction layer to facilitate management.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:151,columnNumber:3},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:151,columnNumber:1},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:149,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.h2,{children:\"Filesystem - tmpfs, proc, sysfs, mqueue, debugfs, cgroups\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:153,columnNumber:1},this)]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\",lineNumber:1,columnNumber:1},this)}function gn(u={}){let{wrapper:n}=u.components||{};return n?(0,t.jsxDEV)(n,Object.assign({},u,{children:(0,t.jsxDEV)(Ce,u,void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\"},this)}),void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx\"},this):Ce(u)}var Nn=gn;function xn(u,n,f){throw new Error(\"Expected \"+(n?\"component\":\"object\")+\" `\"+u+\"` to be defined: you likely forgot to import, pass, or provide it.\"+(f?\"\\nIt\\u2019s referenced in your code at `\"+f+\"` in `/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-40fd9832-53d1-4b99-86a9-6506be367e24.mdx`\":\"\"))}return hn(yn);})();\n/*! Bundled license information:\n\nreact/cjs/react-jsx-dev-runtime.development.js:\n  (**\n   * @license React\n   * react-jsx-dev-runtime.development.js\n   *\n   * Copyright (c) Facebook, Inc. and its affiliates.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   *)\n*/\n;return Component;"
  },
  "_id": "posts/container-deep-dive.mdx",
  "_raw": {
    "sourceFilePath": "posts/container-deep-dive.mdx",
    "sourceFileName": "container-deep-dive.mdx",
    "sourceFileDir": "posts",
    "contentType": "mdx",
    "flattenedPath": "posts/container-deep-dive"
  },
  "type": "Post",
  "slug": "/posts/container-deep-dive",
  "slugAsParams": "container-deep-dive"
}