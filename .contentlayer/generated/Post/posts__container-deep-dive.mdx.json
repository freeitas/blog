{
  "title": "Container Deep Dive",
  "description": "Containers",
  "date": "2025-03-17T00:00:00.000Z",
  "body": {
    "raw": "\n## What is a container?\n\nA container is a standardized unit of software that packages code and all its dependencies so that software can run quickly and consistently in any environment.\n\ncharacteristics:\n\n- immutability\n- isolation of processes and computing resources\n- lightweight, runs as a process on the operating system\n\ncontainer vs virtual machine:\n\n- Virtual Machines (VMs): Each VM runs a complete operating system, including the kernel, and uses a hypervisor to manage multiple VMs on the same hardware. This results in higher resource consumption, longer startup times, and less efficiency in terms of memory and CPU usage.\n- Containers: Share the host operating system's kernel, isolating only the application and its dependencies. This makes them significantly lighter, allowing for more efficient use of resources and almost instantaneous startup. Containers are ideal for scenarios that require rapid scalability and high density of applications on a single host.\n\n<Image\n  src=\"/vmxdocker.png\"\n  width=\"718\"\n  height=\"404\"\n  alt=\"Container vs Docker\"\n/>\n\n## Namespaces and isolation of resources\n\nNamespaces are used so that a container can be executed safely. We need mechanisms to ensure the isolation of resources and processes.\n\nMain technology behind containers to achieve isolation:\n\n- PID (Process ID): Process isolation.\n- NET (Network): Isolation of network interfaces and stack.\n- MNT (Mount): File system isolation.\n- UTS (Unix Timesharing System): Hostname isolation.\n- IPC (Inter-Process Communication): Isolation of communication between processes.\n- USER: User identity isolation.\n\n## Cgroups and control of resources\n\ncgroups (Control Groups)\nA Linux Kernel feature that allows limiting, monitoring, and isolating resource usage of processes\n\n- CPU\n- Memory\n- Disk\n- Network\n\n<Image\n  src=\"/cgroup.png\"\n  width=\"718\"\n  height=\"404\"\n  alt=\"Cgroups and Namespaces\"\n/>\n\n## LXC - Linux Containers\n\nSystem responsible for executing and managing containers, creating an isolated environment so that applications can be executed consistently and efficiently.\n\n- Isolation\n- Resource management\n- Network management and communication between containers\n- Storage: volume management and file systems (Overlay)\n- Monitoring, metrics, logs, and container state\n- Does not have a friendly user interface by default\n- Requires greater knowledge of Linux administration\n\nmost well known:\n\n- LXC - Linux Containers\n- Docker\n- rkt (Rocket)\n- CRI-O\n- Podman\n\nLXC (Linux Containers) - 2008\n\n- First container system that offered a lightweight virtualization environment using cgroups and namespaces of Linux.\n- Is considered low level compared to solutions like Docker, which offer more abstraction and ease of use\n- Uses Linux tools\n- Does not have a friendly user interface by default\n- Requires more knowledge of Linux administration\n\n## Open Container Initiative (OCI)\n\nOpen Container Initiative (OCI):\nThe Open Container Initiative (OCI) is an open and lightweight governance structure, created under the Linux Foundation, with the purpose of establishing open industry standards for container formats and runtimes. The OCI was launched on June 22, 2015, by Docker, CoreOS, and other container industry leaders.\n\nCurrently, the OCI contains three main specifications:\n\n- Runtime Specification (runtime-spec): Defines how to execute a \"filesystem bundle\" that is unpacked on disk. It establishes how the environment should be configured for the container to be started, including requirements such as cgroups, namespaces, device configurations, and permissions.\n- Image Specification (image-spec): Defines how to create an OCI image, which includes the image manifest, filesystem serialization (layers), and image configurations. The image manifest contains metadata about the content and dependencies of the image, while the configuration includes information such as execution commands, environment variables, and other configurations needed to start the container.\n- Distribution Specification (distribution-spec): Introduced in 2020, standardizes the API for container image distribution. This specification is designed to be generic enough to be used as a distribution mechanism for any type of content, allowing container images to be easily stored and retrieved from registries, such as Docker Hub.\n\n## Containerd and runc\n\n- containerd is a lower-level container runtime that manages the container lifecycle, including execution, pausing, stopping, and removing containers. It is a separate project, originally part of Docker, but now an independent component maintained by the Cloud Native Computing Foundation (CNCF).\n  - Relationship between Docker and containerd: Docker uses containerd as one of its fundamental components to efficiently manage containers. Docker's architecture is built on containerd, which in turn uses runc (OCI-compatible) to create and run containers at the system level. Docker CLI and Docker Daemon communicate with containerd to perform high-level operations, such as creating new containers or executing commands in them.\n  - Benefits of containerd: Separating containerd as an independent project brought greater modularity and flexibility to the container ecosystem. Other tools and orchestrators, such as Kubernetes, also use containerd as the standard runtime due to its efficiency and adherence to OCI standards.\n\nThe main components of containerd include:\n\n- Main Daemon: The central service that coordinates all container-related operations, functioning as a gRPC server to manage the container lifecycle (GitHub).\n\n- Client: An interface that allows users to interact with the containerd daemon, sending commands and receiving responses for operations such as creating, running, and managing containers (GitHub).\n\n- Image Storage: Manages the download, storage, and distribution of container images, ensuring that the necessary images are available for container execution (containerd).\n\n- Container Execution: Responsible for starting and supervising the execution of containers, ensuring they operate as expected (containerd).\n\n- Network Primitives: Provides functionality for creating, modifying, and deleting network interfaces, allowing containers to connect to networks as needed (containerd).\n\n- CRI Plugin (Container Runtime Interface): Implements the container runtime interface for Kubernetes, allowing containerd to be used as a runtime in Kubernetes environments (GitHub).\n\n### How containerd and runc work together\n\n- containerd and runc work together to create and manage containers in Docker and other containerization systems that follow the OCI standard.\n- When you run a command like docker run, the Docker CLI communicates with the Docker Daemon to request the creation of a new container.\n- The Docker Daemon then communicates with containerd to manage the container lifecycle.\n- containerd uses runc to effectively create the container, applying all isolation configurations, such as namespaces and cgroups.\n- runc creates the isolated process and configures namespaces and cgroups as defined by OCI specifications. It executes the initial process inside the container (for example, /bin/sh or any specified command).\n- Once the container is running, containerd continues to monitor its state and allows commands such as pause, resume, and stop to be executed through the gRPC API.\n\n### Difference between containerd and Docker Daemon\n\nDocker Daemon: The Docker Daemon (dockerd) is the main process that coordinates all Docker-related operations. It receives commands from the Docker CLI, interacts with containerd, and manages images, containers, networks, and volumes. The Docker Daemon is responsible for providing the high-level interface for developers and operators who use Docker to manage containers easily.\n\ncontainerd: containerd is a lower-level container runtime that handles the container lifecycle, including execution, pausing, restarting, and removing containers. containerd was created to be a modular and independent tool that can be used by other container orchestrators such as Kubernetes. It is responsible for communicating directly with runc for container creation, while the Docker Daemon is more focused on providing a high-level interface and management functionality.\n\nRelationship between containerd and Docker Daemon: The Docker Daemon is built on top of containerd. When you run a Docker command, the Docker Daemon delegates container-related operations to containerd, which in turn uses runc to effectively create and run the container. Thus, the Docker Daemon serves as an orchestration and abstraction layer, while containerd performs lower-level operations.\n\n### About runC\n\nrunc is the low-level container runtime that follows the Open Container Initiative (OCI) specifications, ensuring that any container created with runc complies with the standards defined for portability and interoperability between container tools.\n\nFunction of runc: runc is responsible for creating and executing containers at the lowest level of the system. It uses Linux kernel features, such as namespaces and cgroups, to create an isolated and controlled environment where a container runs. runc is responsible for applying isolation configurations, setting resource limits, and starting the main process inside the container.\n\nHow runc Works: When the command to create a container is passed by containerd, runc reads the generated configuration file, which defines details such as namespaces, cgroups, devices, environment variables, among others. From this configuration, runc creates an isolated process that will be the container. runc does not manage the container lifecycle after its creation, as this is containerd's function.\n\nOCI and runc: By being compatible with OCI specifications, runc ensures that the container format and execution practices are standardized, which means that containers created with runc are portable and can be run in other OCI-compatible environments.\n\nHistory of runc: Originally, runc was an integral part of Docker, but with the creation of OCI, it was extracted and transformed into an independent project to serve as a universal container runtime. This helped promote a more open and interoperable ecosystem, where multiple tools can share the same runtime.\n\nOperation:\n\n- If you have containerd and runc installed, it's possible to create a container directly without using Docker. First, you must prepare a configuration for the container using a JSON file following OCI specifications.\n\n- Then, runc can be used to initialize the container with this configuration file. This process demonstrates how runc acts as the direct executor of the container, while containerd or Docker provide the abstraction layer to facilitate management.\n\n## Filesystem - tmpfs, proc, sysfs, mqueue, debugfs, cgroups\n\nWhen a container is created, some folders are mounted at runtime, such as: /dev, /run, /tmp, /sys, /proc, etc.\n\n### tmpfs\n\ntmpfs is a temporary filesystem that stores data in RAM memory. It combines the functionality of a filesystem and volatile memory, offering an extremely fast storage area. In containers, tmpfs is very useful for storing data that doesn't need to persist after restarting or destroying the container.\n\nMain Characteristics:\n\n- It's mounted in RAM, providing very fast data access.\n- All data stored in tmpfs is volatile and will be lost after container restart.\n- It's useful for storing temporary data, such as caches or intermediate files.\n  Main Folders Mounted with tmpfs:\n- /dev: Often mounted as tmpfs to store devices that are dynamically created and destroyed.\n- /run: Used to store runtime data, such as PID files or sockets.\n- /dev/shm: A shared memory system used for inter-process communication (IPC).\n  Relevant Points and Relationships:\n- tmpfs is frequently used in conjunction with other filesystems like procfs and mqueue to provide temporary areas for process data storage and communication, ensuring isolation and high performance. However, there is no direct dependency between tmpfs and other systems, just combined usage for certain functionalities.\n\n### proc or /procfs\n\nprocfs is a virtual filesystem that provides an interface to access information about the kernel and running processes. Unlike traditional filesystems, it doesn't store data on disk, but rather information dynamically generated by the kernel in real time.\n\nMain Characteristics:\n\n- It's used to access system information, such as CPU usage, memory, information about processes, among others.\n- Typically mounted at /proc inside the container, providing access to kernel state.\n  Main Folders and Files in /proc:\n- /proc/cpuinfo: Contains detailed information about the processor.\n- /proc/meminfo: Provides statistics about memory usage.\n- /proc/[PID]: Contains information about a specific process, where [PID] is the process ID.\n- /proc/mounts: Lists all currently mounted filesystems.\n  Relevant Points and Relationships:\n- procfs doesn't directly depend on other filesystems, but serves as an information source for several others, including mqueue and sysfs, which benefit from the data provided by procfs to understand the state of the system and processes.\n- mqueue doesn't directly access procfs data, but procfs information can be indirectly used to monitor processes that use message queues.\n\n### sysfs\n\nsysfs is a virtual filesystem that provides a hierarchical view of devices and kernel modules. It was introduced to facilitate interaction between the kernel and user space, replacing parts of procfs that were related to device configuration.\n\nMain Characteristics:\n\n- Mounted at /sys, sysfs offers a structured way to interact with devices and their attributes.\n- Allows applications and users to read and modify hardware configurations and kernel modules.\n  Main Folders in /sys:\n- /sys/class: Contains device classes, such as network devices and disks.\n- /sys/block: Provides information about block devices, such as disks and partitions.\n- /sys/devices: Shows all devices connected to the system, structured hierarchically.\n  Relevant Points and Relationships:\n- sysfs complements procfs by providing detailed information about hardware devices, while procfs focuses on processes and kernel states.\n- There is no direct dependency between sysfs and procfs, but they complement each other to provide a complete view of the system and its devices.\n\n### mqueue\n\nmqueue is a filesystem that supports POSIX message queues. It is used for inter-process communication (IPC) through asynchronous messages, allowing different processes to exchange information safely and efficiently.\n\nPOSIX messages (Portable Operating System Interface) are a standard for inter-process communication, allowing information to be sent between different processes in an organized and asynchronous manner, ensuring compatibility and efficiency in UNIX and similar systems.\n\nMain Characteristics:\n\n- Mounted at /dev/mqueue inside containers.\n- Offers an efficient form of inter-process communication, being used in systems that need high performance in message exchange.\n  Folders and Files:\n- /dev/mqueue: Contains message queues created by processes. Each queue is represented as a file in this directory.\n  Relevant Points and Relationships:\n- mqueue operates independently and doesn't directly access procfs data. However, system administration can use procfs to monitor processes that interact with mqueue.\n- mqueue is an independent filesystem and doesn't depend on tmpfs to be mounted. tmpfs can be used together to provide temporary storage, but this is a configuration choice and not a dependency.\n\n### debugfs\n\ndebugfs is a filesystem created for kernel debugging purposes. It allows access to detailed and sometimes sensitive kernel information, being an essential tool for developers who need to debug system behavior.\n\nMain Characteristics:\n\n- It's generally mounted manually only when needed, typically at /sys/kernel/debug.\n- Provides access to information that isn't available in procfs or sysfs.\n  Folders in /sys/kernel/debug:\n- Contains various folders and files that allow interaction with different kernel subsystems.\n- For example, /sys/kernel/debug/tracing offers tools for monitoring kernel events.\n  Relevant Points and Relationships:\n- debugfs doesn't directly depend on procfs or sysfs, but provides complementary debugging information that isn't available in these other filesystems. It's especially useful when detailed data about kernel execution is needed that can't be found in other sources.",
    "code": "var Component=(()=>{var ln=Object.create;var P=Object.defineProperty;var un=Object.getOwnPropertyDescriptor;var cn=Object.getOwnPropertyNames;var fn=Object.getPrototypeOf,mn=Object.prototype.hasOwnProperty;var H=(l,n)=>()=>(n||l((n={exports:{}}).exports,n),n.exports),bn=(l,n)=>{for(var m in n)P(l,m,{get:n[m],enumerable:!0})},xe=(l,n,m,y)=>{if(n&&typeof n==\"object\"||typeof n==\"function\")for(let g of cn(n))!mn.call(l,g)&&g!==m&&P(l,g,{get:()=>n[g],enumerable:!(y=un(n,g))||y.enumerable});return l};var pn=(l,n,m)=>(m=l!=null?ln(fn(l)):{},xe(n||!l||!l.__esModule?P(m,\"default\",{value:l,enumerable:!0}):m,l)),hn=l=>xe(P({},\"__esModule\",{value:!0}),l);var De=H((Dn,ve)=>{ve.exports=React});var je=H(X=>{\"use strict\";(function(){\"use strict\";var l=De(),n=Symbol.for(\"react.element\"),m=Symbol.for(\"react.portal\"),y=Symbol.for(\"react.fragment\"),g=Symbol.for(\"react.strict_mode\"),B=Symbol.for(\"react.profiler\"),G=Symbol.for(\"react.provider\"),K=Symbol.for(\"react.context\"),C=Symbol.for(\"react.forward_ref\"),S=Symbol.for(\"react.suspense\"),F=Symbol.for(\"react.suspense_list\"),k=Symbol.for(\"react.memo\"),M=Symbol.for(\"react.lazy\"),ke=Symbol.for(\"react.offscreen\"),J=Symbol.iterator,Re=\"@@iterator\";function Ee(e){if(e===null||typeof e!=\"object\")return null;var r=J&&e[J]||e[Re];return typeof r==\"function\"?r:null}var v=l.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;function b(e){{for(var r=arguments.length,s=new Array(r>1?r-1:0),i=1;i<r;i++)s[i-1]=arguments[i];Ie(\"error\",e,s)}}function Ie(e,r,s){{var i=v.ReactDebugCurrentFrame,d=i.getStackAddendum();d!==\"\"&&(r+=\"%s\",s=s.concat([d]));var u=s.map(function(a){return String(a)});u.unshift(\"Warning: \"+r),Function.prototype.apply.call(console[e],console,u)}}var Oe=!1,Te=!1,Pe=!1,Se=!1,Fe=!1,Z;Z=Symbol.for(\"react.module.reference\");function Me(e){return!!(typeof e==\"string\"||typeof e==\"function\"||e===y||e===B||Fe||e===g||e===S||e===F||Se||e===ke||Oe||Te||Pe||typeof e==\"object\"&&e!==null&&(e.$$typeof===M||e.$$typeof===k||e.$$typeof===G||e.$$typeof===K||e.$$typeof===C||e.$$typeof===Z||e.getModuleId!==void 0))}function Ae(e,r,s){var i=e.displayName;if(i)return i;var d=r.displayName||r.name||\"\";return d!==\"\"?s+\"(\"+d+\")\":s}function Q(e){return e.displayName||\"Context\"}function _(e){if(e==null)return null;if(typeof e.tag==\"number\"&&b(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"),typeof e==\"function\")return e.displayName||e.name||null;if(typeof e==\"string\")return e;switch(e){case y:return\"Fragment\";case m:return\"Portal\";case B:return\"Profiler\";case g:return\"StrictMode\";case S:return\"Suspense\";case F:return\"SuspenseList\"}if(typeof e==\"object\")switch(e.$$typeof){case K:var r=e;return Q(r)+\".Consumer\";case G:var s=e;return Q(s._context)+\".Provider\";case C:return Ae(e,e.render,\"ForwardRef\");case k:var i=e.displayName||null;return i!==null?i:_(e.type)||\"Memo\";case M:{var d=e,u=d._payload,a=d._init;try{return _(a(u))}catch{return null}}}return null}var x=Object.assign,U=0,ee,ne,te,re,se,ie,oe;function ae(){}ae.__reactDisabledLog=!0;function Le(){{if(U===0){ee=console.log,ne=console.info,te=console.warn,re=console.error,se=console.group,ie=console.groupCollapsed,oe=console.groupEnd;var e={configurable:!0,enumerable:!0,value:ae,writable:!0};Object.defineProperties(console,{info:e,log:e,warn:e,error:e,group:e,groupCollapsed:e,groupEnd:e})}U++}}function We(){{if(U--,U===0){var e={configurable:!0,enumerable:!0,writable:!0};Object.defineProperties(console,{log:x({},e,{value:ee}),info:x({},e,{value:ne}),warn:x({},e,{value:te}),error:x({},e,{value:re}),group:x({},e,{value:se}),groupCollapsed:x({},e,{value:ie}),groupEnd:x({},e,{value:oe})})}U<0&&b(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\")}}var A=v.ReactCurrentDispatcher,L;function R(e,r,s){{if(L===void 0)try{throw Error()}catch(d){var i=d.stack.trim().match(/\\n( *(at )?)/);L=i&&i[1]||\"\"}return`\n`+L+e}}var W=!1,E;{var qe=typeof WeakMap==\"function\"?WeakMap:Map;E=new qe}function de(e,r){if(!e||W)return\"\";{var s=E.get(e);if(s!==void 0)return s}var i;W=!0;var d=Error.prepareStackTrace;Error.prepareStackTrace=void 0;var u;u=A.current,A.current=null,Le();try{if(r){var a=function(){throw Error()};if(Object.defineProperty(a.prototype,\"props\",{set:function(){throw Error()}}),typeof Reflect==\"object\"&&Reflect.construct){try{Reflect.construct(a,[])}catch(N){i=N}Reflect.construct(e,[],a)}else{try{a.call()}catch(N){i=N}e.call(a.prototype)}}else{try{throw Error()}catch(N){i=N}e()}}catch(N){if(N&&i&&typeof N.stack==\"string\"){for(var o=N.stack.split(`\n`),p=i.stack.split(`\n`),c=o.length-1,f=p.length-1;c>=1&&f>=0&&o[c]!==p[f];)f--;for(;c>=1&&f>=0;c--,f--)if(o[c]!==p[f]){if(c!==1||f!==1)do if(c--,f--,f<0||o[c]!==p[f]){var h=`\n`+o[c].replace(\" at new \",\" at \");return e.displayName&&h.includes(\"<anonymous>\")&&(h=h.replace(\"<anonymous>\",e.displayName)),typeof e==\"function\"&&E.set(e,h),h}while(c>=1&&f>=0);break}}}finally{W=!1,A.current=u,We(),Error.prepareStackTrace=d}var j=e?e.displayName||e.name:\"\",ye=j?R(j):\"\";return typeof e==\"function\"&&E.set(e,ye),ye}function Ve(e,r,s){return de(e,!1)}function Ye(e){var r=e.prototype;return!!(r&&r.isReactComponent)}function I(e,r,s){if(e==null)return\"\";if(typeof e==\"function\")return de(e,Ye(e));if(typeof e==\"string\")return R(e);switch(e){case S:return R(\"Suspense\");case F:return R(\"SuspenseList\")}if(typeof e==\"object\")switch(e.$$typeof){case C:return Ve(e.render);case k:return I(e.type,r,s);case M:{var i=e,d=i._payload,u=i._init;try{return I(u(d),r,s)}catch{}}}return\"\"}var O=Object.prototype.hasOwnProperty,le={},ue=v.ReactDebugCurrentFrame;function T(e){if(e){var r=e._owner,s=I(e.type,e._source,r?r.type:null);ue.setExtraStackFrame(s)}else ue.setExtraStackFrame(null)}function $e(e,r,s,i,d){{var u=Function.call.bind(O);for(var a in e)if(u(e,a)){var o=void 0;try{if(typeof e[a]!=\"function\"){var p=Error((i||\"React class\")+\": \"+s+\" type `\"+a+\"` is invalid; it must be a function, usually from the `prop-types` package, but received `\"+typeof e[a]+\"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");throw p.name=\"Invariant Violation\",p}o=e[a](r,a,i,s,null,\"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\")}catch(c){o=c}o&&!(o instanceof Error)&&(T(d),b(\"%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\",i||\"React class\",s,a,typeof o),T(null)),o instanceof Error&&!(o.message in le)&&(le[o.message]=!0,T(d),b(\"Failed %s type: %s\",s,o.message),T(null))}}}var ze=Array.isArray;function q(e){return ze(e)}function He(e){{var r=typeof Symbol==\"function\"&&Symbol.toStringTag,s=r&&e[Symbol.toStringTag]||e.constructor.name||\"Object\";return s}}function Xe(e){try{return ce(e),!1}catch{return!0}}function ce(e){return\"\"+e}function fe(e){if(Xe(e))return b(\"The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.\",He(e)),ce(e)}var w=v.ReactCurrentOwner,Be={key:!0,ref:!0,__self:!0,__source:!0},me,be,V;V={};function Ge(e){if(O.call(e,\"ref\")){var r=Object.getOwnPropertyDescriptor(e,\"ref\").get;if(r&&r.isReactWarning)return!1}return e.ref!==void 0}function Ke(e){if(O.call(e,\"key\")){var r=Object.getOwnPropertyDescriptor(e,\"key\").get;if(r&&r.isReactWarning)return!1}return e.key!==void 0}function Je(e,r){if(typeof e.ref==\"string\"&&w.current&&r&&w.current.stateNode!==r){var s=_(w.current.type);V[s]||(b('Component \"%s\" contains the string ref \"%s\". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref',_(w.current.type),e.ref),V[s]=!0)}}function Ze(e,r){{var s=function(){me||(me=!0,b(\"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\",r))};s.isReactWarning=!0,Object.defineProperty(e,\"key\",{get:s,configurable:!0})}}function Qe(e,r){{var s=function(){be||(be=!0,b(\"%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\",r))};s.isReactWarning=!0,Object.defineProperty(e,\"ref\",{get:s,configurable:!0})}}var en=function(e,r,s,i,d,u,a){var o={$$typeof:n,type:e,key:r,ref:s,props:a,_owner:u};return o._store={},Object.defineProperty(o._store,\"validated\",{configurable:!1,enumerable:!1,writable:!0,value:!1}),Object.defineProperty(o,\"_self\",{configurable:!1,enumerable:!1,writable:!1,value:i}),Object.defineProperty(o,\"_source\",{configurable:!1,enumerable:!1,writable:!1,value:d}),Object.freeze&&(Object.freeze(o.props),Object.freeze(o)),o};function nn(e,r,s,i,d){{var u,a={},o=null,p=null;s!==void 0&&(fe(s),o=\"\"+s),Ke(r)&&(fe(r.key),o=\"\"+r.key),Ge(r)&&(p=r.ref,Je(r,d));for(u in r)O.call(r,u)&&!Be.hasOwnProperty(u)&&(a[u]=r[u]);if(e&&e.defaultProps){var c=e.defaultProps;for(u in c)a[u]===void 0&&(a[u]=c[u])}if(o||p){var f=typeof e==\"function\"?e.displayName||e.name||\"Unknown\":e;o&&Ze(a,f),p&&Qe(a,f)}return en(e,o,p,d,i,w.current,a)}}var Y=v.ReactCurrentOwner,pe=v.ReactDebugCurrentFrame;function D(e){if(e){var r=e._owner,s=I(e.type,e._source,r?r.type:null);pe.setExtraStackFrame(s)}else pe.setExtraStackFrame(null)}var $;$=!1;function z(e){return typeof e==\"object\"&&e!==null&&e.$$typeof===n}function he(){{if(Y.current){var e=_(Y.current.type);if(e)return`\n\nCheck the render method of \\``+e+\"`.\"}return\"\"}}function tn(e){{if(e!==void 0){var r=e.fileName.replace(/^.*[\\\\\\/]/,\"\"),s=e.lineNumber;return`\n\nCheck your code at `+r+\":\"+s+\".\"}return\"\"}}var _e={};function rn(e){{var r=he();if(!r){var s=typeof e==\"string\"?e:e.displayName||e.name;s&&(r=`\n\nCheck the top-level render call using <`+s+\">.\")}return r}}function Ne(e,r){{if(!e._store||e._store.validated||e.key!=null)return;e._store.validated=!0;var s=rn(r);if(_e[s])return;_e[s]=!0;var i=\"\";e&&e._owner&&e._owner!==Y.current&&(i=\" It was passed a child from \"+_(e._owner.type)+\".\"),D(e),b('Each child in a list should have a unique \"key\" prop.%s%s See https://reactjs.org/link/warning-keys for more information.',s,i),D(null)}}function ge(e,r){{if(typeof e!=\"object\")return;if(q(e))for(var s=0;s<e.length;s++){var i=e[s];z(i)&&Ne(i,r)}else if(z(e))e._store&&(e._store.validated=!0);else if(e){var d=Ee(e);if(typeof d==\"function\"&&d!==e.entries)for(var u=d.call(e),a;!(a=u.next()).done;)z(a.value)&&Ne(a.value,r)}}}function sn(e){{var r=e.type;if(r==null||typeof r==\"string\")return;var s;if(typeof r==\"function\")s=r.propTypes;else if(typeof r==\"object\"&&(r.$$typeof===C||r.$$typeof===k))s=r.propTypes;else return;if(s){var i=_(r);$e(s,e.props,\"prop\",i,e)}else if(r.PropTypes!==void 0&&!$){$=!0;var d=_(r);b(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\",d||\"Unknown\")}typeof r.getDefaultProps==\"function\"&&!r.getDefaultProps.isReactClassApproved&&b(\"getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.\")}}function on(e){{for(var r=Object.keys(e.props),s=0;s<r.length;s++){var i=r[s];if(i!==\"children\"&&i!==\"key\"){D(e),b(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\",i),D(null);break}}e.ref!==null&&(D(e),b(\"Invalid attribute `ref` supplied to `React.Fragment`.\"),D(null))}}function an(e,r,s,i,d,u){{var a=Me(e);if(!a){var o=\"\";(e===void 0||typeof e==\"object\"&&e!==null&&Object.keys(e).length===0)&&(o+=\" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\");var p=tn(d);p?o+=p:o+=he();var c;e===null?c=\"null\":q(e)?c=\"array\":e!==void 0&&e.$$typeof===n?(c=\"<\"+(_(e.type)||\"Unknown\")+\" />\",o=\" Did you accidentally export a JSX literal instead of a component?\"):c=typeof e,b(\"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\",c,o)}var f=nn(e,r,s,d,u);if(f==null)return f;if(a){var h=r.children;if(h!==void 0)if(i)if(q(h)){for(var j=0;j<h.length;j++)ge(h[j],e);Object.freeze&&Object.freeze(h)}else b(\"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\");else ge(h,e)}return e===y?on(f):sn(f),f}}var dn=an;X.Fragment=y,X.jsxDEV=dn})()});var we=H((Un,Ue)=>{\"use strict\";Ue.exports=je()});var xn={};bn(xn,{default:()=>gn,frontmatter:()=>_n});var t=pn(we()),_n={title:\"Container Deep Dive\",description:\"Containers\",date:\"2025-03-17\"};function Ce(l){let n=Object.assign({h2:\"h2\",p:\"p\",ul:\"ul\",li:\"li\",h3:\"h3\"},l.components),{Image:m}=n;return m||yn(\"Image\",!0,\"22:1-27:3\"),(0,t.jsxDEV)(t.Fragment,{children:[(0,t.jsxDEV)(n.h2,{children:\"What is a container?\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:7,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"A container is a standardized unit of software that packages code and all its dependencies so that software can run quickly and consistently in any environment.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:9,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"characteristics:\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:11,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.ul,{children:[`\n`,(0,t.jsxDEV)(n.li,{children:\"immutability\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:13,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"isolation of processes and computing resources\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:14,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"lightweight, runs as a process on the operating system\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:15,columnNumber:1},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:13,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"container vs virtual machine:\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:17,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.ul,{children:[`\n`,(0,t.jsxDEV)(n.li,{children:\"Virtual Machines (VMs): Each VM runs a complete operating system, including the kernel, and uses a hypervisor to manage multiple VMs on the same hardware. This results in higher resource consumption, longer startup times, and less efficiency in terms of memory and CPU usage.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:19,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"Containers: Share the host operating system's kernel, isolating only the application and its dependencies. This makes them significantly lighter, allowing for more efficient use of resources and almost instantaneous startup. Containers are ideal for scenarios that require rapid scalability and high density of applications on a single host.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:20,columnNumber:1},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:19,columnNumber:1},this),`\n`,(0,t.jsxDEV)(m,{src:\"/vmxdocker.png\",width:\"718\",height:\"404\",alt:\"Container vs Docker\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:22,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.h2,{children:\"Namespaces and isolation of resources\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:29,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"Namespaces are used so that a container can be executed safely. We need mechanisms to ensure the isolation of resources and processes.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:31,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"Main technology behind containers to achieve isolation:\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:33,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.ul,{children:[`\n`,(0,t.jsxDEV)(n.li,{children:\"PID (Process ID): Process isolation.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:35,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"NET (Network): Isolation of network interfaces and stack.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:36,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"MNT (Mount): File system isolation.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:37,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"UTS (Unix Timesharing System): Hostname isolation.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:38,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"IPC (Inter-Process Communication): Isolation of communication between processes.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:39,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"USER: User identity isolation.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:40,columnNumber:1},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:35,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.h2,{children:\"Cgroups and control of resources\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:42,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:`cgroups (Control Groups)\nA Linux Kernel feature that allows limiting, monitoring, and isolating resource usage of processes`},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:44,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.ul,{children:[`\n`,(0,t.jsxDEV)(n.li,{children:\"CPU\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:47,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"Memory\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:48,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"Disk\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:49,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"Network\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:50,columnNumber:1},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:47,columnNumber:1},this),`\n`,(0,t.jsxDEV)(m,{src:\"/cgroup.png\",width:\"718\",height:\"404\",alt:\"Cgroups and Namespaces\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:52,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.h2,{children:\"LXC - Linux Containers\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:59,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"System responsible for executing and managing containers, creating an isolated environment so that applications can be executed consistently and efficiently.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:61,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.ul,{children:[`\n`,(0,t.jsxDEV)(n.li,{children:\"Isolation\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:63,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"Resource management\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:64,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"Network management and communication between containers\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:65,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"Storage: volume management and file systems (Overlay)\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:66,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"Monitoring, metrics, logs, and container state\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:67,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"Does not have a friendly user interface by default\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:68,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"Requires greater knowledge of Linux administration\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:69,columnNumber:1},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:63,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"most well known:\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:71,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.ul,{children:[`\n`,(0,t.jsxDEV)(n.li,{children:\"LXC - Linux Containers\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:73,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"Docker\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:74,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"rkt (Rocket)\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:75,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"CRI-O\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:76,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"Podman\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:77,columnNumber:1},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:73,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"LXC (Linux Containers) - 2008\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:79,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.ul,{children:[`\n`,(0,t.jsxDEV)(n.li,{children:\"First container system that offered a lightweight virtualization environment using cgroups and namespaces of Linux.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:81,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"Is considered low level compared to solutions like Docker, which offer more abstraction and ease of use\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:82,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"Uses Linux tools\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:83,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"Does not have a friendly user interface by default\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:84,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"Requires more knowledge of Linux administration\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:85,columnNumber:1},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:81,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.h2,{children:\"Open Container Initiative (OCI)\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:87,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:`Open Container Initiative (OCI):\nThe Open Container Initiative (OCI) is an open and lightweight governance structure, created under the Linux Foundation, with the purpose of establishing open industry standards for container formats and runtimes. The OCI was launched on June 22, 2015, by Docker, CoreOS, and other container industry leaders.`},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:89,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"Currently, the OCI contains three main specifications:\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:92,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.ul,{children:[`\n`,(0,t.jsxDEV)(n.li,{children:'Runtime Specification (runtime-spec): Defines how to execute a \"filesystem bundle\" that is unpacked on disk. It establishes how the environment should be configured for the container to be started, including requirements such as cgroups, namespaces, device configurations, and permissions.'},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:94,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"Image Specification (image-spec): Defines how to create an OCI image, which includes the image manifest, filesystem serialization (layers), and image configurations. The image manifest contains metadata about the content and dependencies of the image, while the configuration includes information such as execution commands, environment variables, and other configurations needed to start the container.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:95,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"Distribution Specification (distribution-spec): Introduced in 2020, standardizes the API for container image distribution. This specification is designed to be generic enough to be used as a distribution mechanism for any type of content, allowing container images to be easily stored and retrieved from registries, such as Docker Hub.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:96,columnNumber:1},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:94,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.h2,{children:\"Containerd and runc\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:98,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.ul,{children:[`\n`,(0,t.jsxDEV)(n.li,{children:[\"containerd is a lower-level container runtime that manages the container lifecycle, including execution, pausing, stopping, and removing containers. It is a separate project, originally part of Docker, but now an independent component maintained by the Cloud Native Computing Foundation (CNCF).\",`\n`,(0,t.jsxDEV)(n.ul,{children:[`\n`,(0,t.jsxDEV)(n.li,{children:\"Relationship between Docker and containerd: Docker uses containerd as one of its fundamental components to efficiently manage containers. Docker's architecture is built on containerd, which in turn uses runc (OCI-compatible) to create and run containers at the system level. Docker CLI and Docker Daemon communicate with containerd to perform high-level operations, such as creating new containers or executing commands in them.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:101,columnNumber:3},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"Benefits of containerd: Separating containerd as an independent project brought greater modularity and flexibility to the container ecosystem. Other tools and orchestrators, such as Kubernetes, also use containerd as the standard runtime due to its efficiency and adherence to OCI standards.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:102,columnNumber:3},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:101,columnNumber:3},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:100,columnNumber:1},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:100,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"The main components of containerd include:\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:104,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.ul,{children:[`\n`,(0,t.jsxDEV)(n.li,{children:[`\n`,(0,t.jsxDEV)(n.p,{children:\"Main Daemon: The central service that coordinates all container-related operations, functioning as a gRPC server to manage the container lifecycle (GitHub).\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:106,columnNumber:3},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:106,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:[`\n`,(0,t.jsxDEV)(n.p,{children:\"Client: An interface that allows users to interact with the containerd daemon, sending commands and receiving responses for operations such as creating, running, and managing containers (GitHub).\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:108,columnNumber:3},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:108,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:[`\n`,(0,t.jsxDEV)(n.p,{children:\"Image Storage: Manages the download, storage, and distribution of container images, ensuring that the necessary images are available for container execution (containerd).\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:110,columnNumber:3},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:110,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:[`\n`,(0,t.jsxDEV)(n.p,{children:\"Container Execution: Responsible for starting and supervising the execution of containers, ensuring they operate as expected (containerd).\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:112,columnNumber:3},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:112,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:[`\n`,(0,t.jsxDEV)(n.p,{children:\"Network Primitives: Provides functionality for creating, modifying, and deleting network interfaces, allowing containers to connect to networks as needed (containerd).\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:114,columnNumber:3},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:114,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:[`\n`,(0,t.jsxDEV)(n.p,{children:\"CRI Plugin (Container Runtime Interface): Implements the container runtime interface for Kubernetes, allowing containerd to be used as a runtime in Kubernetes environments (GitHub).\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:116,columnNumber:3},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:116,columnNumber:1},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:106,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.h3,{children:\"How containerd and runc work together\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:118,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.ul,{children:[`\n`,(0,t.jsxDEV)(n.li,{children:\"containerd and runc work together to create and manage containers in Docker and other containerization systems that follow the OCI standard.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:120,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"When you run a command like docker run, the Docker CLI communicates with the Docker Daemon to request the creation of a new container.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:121,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"The Docker Daemon then communicates with containerd to manage the container lifecycle.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:122,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"containerd uses runc to effectively create the container, applying all isolation configurations, such as namespaces and cgroups.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:123,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"runc creates the isolated process and configures namespaces and cgroups as defined by OCI specifications. It executes the initial process inside the container (for example, /bin/sh or any specified command).\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:124,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"Once the container is running, containerd continues to monitor its state and allows commands such as pause, resume, and stop to be executed through the gRPC API.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:125,columnNumber:1},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:120,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.h3,{children:\"Difference between containerd and Docker Daemon\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:127,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"Docker Daemon: The Docker Daemon (dockerd) is the main process that coordinates all Docker-related operations. It receives commands from the Docker CLI, interacts with containerd, and manages images, containers, networks, and volumes. The Docker Daemon is responsible for providing the high-level interface for developers and operators who use Docker to manage containers easily.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:129,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"containerd: containerd is a lower-level container runtime that handles the container lifecycle, including execution, pausing, restarting, and removing containers. containerd was created to be a modular and independent tool that can be used by other container orchestrators such as Kubernetes. It is responsible for communicating directly with runc for container creation, while the Docker Daemon is more focused on providing a high-level interface and management functionality.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:131,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"Relationship between containerd and Docker Daemon: The Docker Daemon is built on top of containerd. When you run a Docker command, the Docker Daemon delegates container-related operations to containerd, which in turn uses runc to effectively create and run the container. Thus, the Docker Daemon serves as an orchestration and abstraction layer, while containerd performs lower-level operations.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:133,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.h3,{children:\"About runC\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:135,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"runc is the low-level container runtime that follows the Open Container Initiative (OCI) specifications, ensuring that any container created with runc complies with the standards defined for portability and interoperability between container tools.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:137,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"Function of runc: runc is responsible for creating and executing containers at the lowest level of the system. It uses Linux kernel features, such as namespaces and cgroups, to create an isolated and controlled environment where a container runs. runc is responsible for applying isolation configurations, setting resource limits, and starting the main process inside the container.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:139,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"How runc Works: When the command to create a container is passed by containerd, runc reads the generated configuration file, which defines details such as namespaces, cgroups, devices, environment variables, among others. From this configuration, runc creates an isolated process that will be the container. runc does not manage the container lifecycle after its creation, as this is containerd's function.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:141,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"OCI and runc: By being compatible with OCI specifications, runc ensures that the container format and execution practices are standardized, which means that containers created with runc are portable and can be run in other OCI-compatible environments.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:143,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"History of runc: Originally, runc was an integral part of Docker, but with the creation of OCI, it was extracted and transformed into an independent project to serve as a universal container runtime. This helped promote a more open and interoperable ecosystem, where multiple tools can share the same runtime.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:145,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"Operation:\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:147,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.ul,{children:[`\n`,(0,t.jsxDEV)(n.li,{children:[`\n`,(0,t.jsxDEV)(n.p,{children:\"If you have containerd and runc installed, it's possible to create a container directly without using Docker. First, you must prepare a configuration for the container using a JSON file following OCI specifications.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:149,columnNumber:3},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:149,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:[`\n`,(0,t.jsxDEV)(n.p,{children:\"Then, runc can be used to initialize the container with this configuration file. This process demonstrates how runc acts as the direct executor of the container, while containerd or Docker provide the abstraction layer to facilitate management.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:151,columnNumber:3},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:151,columnNumber:1},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:149,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.h2,{children:\"Filesystem - tmpfs, proc, sysfs, mqueue, debugfs, cgroups\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:153,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"When a container is created, some folders are mounted at runtime, such as: /dev, /run, /tmp, /sys, /proc, etc.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:155,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.h3,{children:\"tmpfs\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:157,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"tmpfs is a temporary filesystem that stores data in RAM memory. It combines the functionality of a filesystem and volatile memory, offering an extremely fast storage area. In containers, tmpfs is very useful for storing data that doesn't need to persist after restarting or destroying the container.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:159,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"Main Characteristics:\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:161,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.ul,{children:[`\n`,(0,t.jsxDEV)(n.li,{children:\"It's mounted in RAM, providing very fast data access.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:163,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"All data stored in tmpfs is volatile and will be lost after container restart.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:164,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:`It's useful for storing temporary data, such as caches or intermediate files.\nMain Folders Mounted with tmpfs:`},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:165,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"/dev: Often mounted as tmpfs to store devices that are dynamically created and destroyed.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:167,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"/run: Used to store runtime data, such as PID files or sockets.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:168,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:`/dev/shm: A shared memory system used for inter-process communication (IPC).\nRelevant Points and Relationships:`},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:169,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"tmpfs is frequently used in conjunction with other filesystems like procfs and mqueue to provide temporary areas for process data storage and communication, ensuring isolation and high performance. However, there is no direct dependency between tmpfs and other systems, just combined usage for certain functionalities.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:171,columnNumber:1},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:163,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.h3,{children:\"proc or /procfs\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:173,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"procfs is a virtual filesystem that provides an interface to access information about the kernel and running processes. Unlike traditional filesystems, it doesn't store data on disk, but rather information dynamically generated by the kernel in real time.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:175,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"Main Characteristics:\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:177,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.ul,{children:[`\n`,(0,t.jsxDEV)(n.li,{children:\"It's used to access system information, such as CPU usage, memory, information about processes, among others.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:179,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:`Typically mounted at /proc inside the container, providing access to kernel state.\nMain Folders and Files in /proc:`},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:180,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"/proc/cpuinfo: Contains detailed information about the processor.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:182,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"/proc/meminfo: Provides statistics about memory usage.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:183,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"/proc/[PID]: Contains information about a specific process, where [PID] is the process ID.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:184,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:`/proc/mounts: Lists all currently mounted filesystems.\nRelevant Points and Relationships:`},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:185,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"procfs doesn't directly depend on other filesystems, but serves as an information source for several others, including mqueue and sysfs, which benefit from the data provided by procfs to understand the state of the system and processes.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:187,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"mqueue doesn't directly access procfs data, but procfs information can be indirectly used to monitor processes that use message queues.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:188,columnNumber:1},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:179,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.h3,{children:\"sysfs\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:190,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"sysfs is a virtual filesystem that provides a hierarchical view of devices and kernel modules. It was introduced to facilitate interaction between the kernel and user space, replacing parts of procfs that were related to device configuration.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:192,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"Main Characteristics:\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:194,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.ul,{children:[`\n`,(0,t.jsxDEV)(n.li,{children:\"Mounted at /sys, sysfs offers a structured way to interact with devices and their attributes.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:196,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:`Allows applications and users to read and modify hardware configurations and kernel modules.\nMain Folders in /sys:`},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:197,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"/sys/class: Contains device classes, such as network devices and disks.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:199,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"/sys/block: Provides information about block devices, such as disks and partitions.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:200,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:`/sys/devices: Shows all devices connected to the system, structured hierarchically.\nRelevant Points and Relationships:`},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:201,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"sysfs complements procfs by providing detailed information about hardware devices, while procfs focuses on processes and kernel states.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:203,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"There is no direct dependency between sysfs and procfs, but they complement each other to provide a complete view of the system and its devices.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:204,columnNumber:1},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:196,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.h3,{children:\"mqueue\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:206,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"mqueue is a filesystem that supports POSIX message queues. It is used for inter-process communication (IPC) through asynchronous messages, allowing different processes to exchange information safely and efficiently.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:208,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"POSIX messages (Portable Operating System Interface) are a standard for inter-process communication, allowing information to be sent between different processes in an organized and asynchronous manner, ensuring compatibility and efficiency in UNIX and similar systems.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:210,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"Main Characteristics:\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:212,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.ul,{children:[`\n`,(0,t.jsxDEV)(n.li,{children:\"Mounted at /dev/mqueue inside containers.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:214,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:`Offers an efficient form of inter-process communication, being used in systems that need high performance in message exchange.\nFolders and Files:`},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:215,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:`/dev/mqueue: Contains message queues created by processes. Each queue is represented as a file in this directory.\nRelevant Points and Relationships:`},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:217,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"mqueue operates independently and doesn't directly access procfs data. However, system administration can use procfs to monitor processes that interact with mqueue.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:219,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"mqueue is an independent filesystem and doesn't depend on tmpfs to be mounted. tmpfs can be used together to provide temporary storage, but this is a configuration choice and not a dependency.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:220,columnNumber:1},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:214,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.h3,{children:\"debugfs\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:222,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"debugfs is a filesystem created for kernel debugging purposes. It allows access to detailed and sometimes sensitive kernel information, being an essential tool for developers who need to debug system behavior.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:224,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.p,{children:\"Main Characteristics:\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:226,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.ul,{children:[`\n`,(0,t.jsxDEV)(n.li,{children:\"It's generally mounted manually only when needed, typically at /sys/kernel/debug.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:228,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:`Provides access to information that isn't available in procfs or sysfs.\nFolders in /sys/kernel/debug:`},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:229,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"Contains various folders and files that allow interaction with different kernel subsystems.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:231,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:`For example, /sys/kernel/debug/tracing offers tools for monitoring kernel events.\nRelevant Points and Relationships:`},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:232,columnNumber:1},this),`\n`,(0,t.jsxDEV)(n.li,{children:\"debugfs doesn't directly depend on procfs or sysfs, but provides complementary debugging information that isn't available in these other filesystems. It's especially useful when detailed data about kernel execution is needed that can't be found in other sources.\"},void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:234,columnNumber:1},this),`\n`]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:228,columnNumber:1},this)]},void 0,!0,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\",lineNumber:1,columnNumber:1},this)}function Nn(l={}){let{wrapper:n}=l.components||{};return n?(0,t.jsxDEV)(n,Object.assign({},l,{children:(0,t.jsxDEV)(Ce,l,void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\"},this)}),void 0,!1,{fileName:\"/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx\"},this):Ce(l)}var gn=Nn;function yn(l,n,m){throw new Error(\"Expected \"+(n?\"component\":\"object\")+\" `\"+l+\"` to be defined: you likely forgot to import, pass, or provide it.\"+(m?\"\\nIt\\u2019s referenced in your code at `\"+m+\"` in `/Users/freitas/Documents/projects/blog/content/posts/_mdx_bundler_entry_point-57312991-871d-44a6-8b3f-f4f6199db9d1.mdx`\":\"\"))}return hn(xn);})();\n/*! Bundled license information:\n\nreact/cjs/react-jsx-dev-runtime.development.js:\n  (**\n   * @license React\n   * react-jsx-dev-runtime.development.js\n   *\n   * Copyright (c) Facebook, Inc. and its affiliates.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   *)\n*/\n;return Component;"
  },
  "_id": "posts/container-deep-dive.mdx",
  "_raw": {
    "sourceFilePath": "posts/container-deep-dive.mdx",
    "sourceFileName": "container-deep-dive.mdx",
    "sourceFileDir": "posts",
    "contentType": "mdx",
    "flattenedPath": "posts/container-deep-dive"
  },
  "type": "Post",
  "slug": "/posts/container-deep-dive",
  "slugAsParams": "container-deep-dive"
}